import {v4 as uuidv4} from 'uuid';

/**
 * @description Meeting Webex assistance transcription feature.
 * @exports
 * @class Transcription
 */
export default class Transcription {
  /**
   * @param {string} webSocketUrl
   * @param {object} members
   * @param {sessionID} sessionId
   * @param {string} token
   * @constructor
   * @memberof Transcription
   */
  constructor(webSocketUrl, members, sessionId, token) {
    this.webSocketUrl = webSocketUrl;
    this.members = members;
    this.sessionID = sessionId;
    this.token = token;
    this.webSocket = {};
  }

  /**
   * Connects to Low Latency Mercury connection
   *
   * @param {string} token
   * @param {string} sessionID
   * @returns {Promise<void>}
   */
  async connect() {
    this.webSocket = new WebSocket(`${this.webSocketUrl}?outboundWireFormat=text&bufferStates=true&aliasHttpStatus=true`); // eslint-disable-line no-undef

    this.webSocket.onopen = () => {
      this.webSocket.send(JSON.stringify({
        id: uuidv4(),
        type: 'authorization',
        data: {token: `Bearer ${this.token}`},
        trackingId: this.sessionID + Date.now.toString()
      }));
    };
  }

  /**
   * Get current speaker from the given csis payload
   *
   * @private
   * @param {object} csis
   * @returns {object}
   */
  getSpeaker(csis) {
    return Object.values(this.members.membersCollection.members).find((member) => {
      const memberCSIs = member.participant.status.csis;
      let selfIsSpeaking = false;

      for (const csi of csis) {
        if (memberCSIs.includes(csi)) {
          selfIsSpeaking = true;
          break;
        }
      }

      return selfIsSpeaking;
    });
  }

  /**
   * pass the transcription inside the callback to return the payload
   *
   * @param {function} callback
   * @returns {void}
   */
  getContent(callback) {
    let data, csis, speaker, transcription;

    this.webSocket.onmessage = (event) => {
      data = JSON.parse(event.data);
      csis = data.data?.voiceaPayload?.csis || [];
      speaker = this.getSpeaker(csis);
      transcription = data.data?.voiceaPayload?.data || '';

      this.webSocket.send(JSON.stringify({messageID: data.id, type: 'ack'}));

      if (transcription) {
        callback(
          {
            speaker: speaker?.name,
            transcription,
            timestamp: data.timestamp,
            type: data?.data?.voiceaPayload?.type
          }
        );
      }
    };
  }

  disconnect() {
    this.webSocket.close();
  }
}

